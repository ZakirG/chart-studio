When a user signs in, they land on a clean “Home” view that feels like a reporting workspace, not a database. A short header shows their name, office, and the environment selector if they have access to multiple offices. The main canvas renders their **default dashboard** (or a curated starter if they’re new), with skeleton loaders fading into live charts as data streams in. Behind the scenes the app issues a few fast GraphQL calls: the user profile and permissions, the list of **saved dashboards** (ids, names, last viewed), the catalog of **report templates** grouped by category, and lightweight **data-source metadata** (field names/types, parameter definitions, and row limits). For the dashboard currently in view, the client requests the saved **layout** and each **card’s chartSpec**, then kicks off batched `runChart` executions; above-the-fold cards are fetched first for snappy perceived performance.

From here, the user can simply browse metrics—hovering shows tooltips, clicking legends filters series, and KPI tiles deep-link to their source tables. A left rail provides quick navigation: “Dashboards,” “Templates,” and “Data Explorer.” Selecting “Dashboards” opens a searchable list of their own and shared boards with recency pins and a thumbnail preview of the first row of charts. Opening another dashboard replaces the canvas and repeats the same fetch: layout + specs, then data, with cached results reused when parameters match.

If they want to build, clicking “New Dashboard” brings up a two-step flow: choose a **template** or start blank, then name it. The editor opens with a gridded canvas and an inspector. On the right, a **Fields & Data Sources** panel appears after the client pulls the chosen data-source schema and parameter prompts. The user drags a chart card onto the grid, picks a data source, supplies parameters (e.g., date range, office), and then drags fields to shelves like X, Y, Series, and Filters. Each change updates a local **chartSpec** and triggers a debounced `runChart`. The chart preview re-renders with Recharts, and the user can resize or move the card via drag handles. Pressing “Save” persists both the dashboard’s **grid layout** and each card’s **chartSpec** to the backend; the UI shows a brief toast and optimistic updates keep the canvas responsive.

Exploration for power users lives in the **Data Explorer**. Opening it splits the screen: a schema browser on the left (fetched from the same metadata service) and a SQL editor on the right. The editor provides SQL highlighting and **autocomplete** for tables and columns derived from the metadata call. Running a query executes server-side with enforced timeouts and row limits; results render in a virtualized table with column sorting and one-click CSV/JSON export. If a user finds something useful, they can “Save as Card,” which wraps the SQL and minimal presentation options into a new **dataSource** entry (or references an existing one) and returns them to the dashboard builder with a prepopulated chart card.

Throughout the experience, navigation is predictable and stateful. The back button returns to the previous dashboard; switching the office filter at the top invalidates cached queries and refetches only what’s needed. Empty states are helpful rather than blank: if a dashboard has no cards, the canvas nudges the user to add from templates like “Sales Performance” or “Accounts Receivable.” Errors are caught at the card level so one failing query doesn’t blank the whole board. When the user logs out and later returns, the app restores them to their last dashboard view, prefetching its layout and the newest data so charts are live within a moment.
